## 2.JMockit 常见使用

+ ### mock静态方法

在mock静态方法时，只要在Record时，传入对应的MethodClass.class即可，如下：

~~~java
new Expectations(LocaleI18nResolver.class){
     {
         LocaleI18nResolver.resolve(anyString, anyString, anyString);
         result = ... // 定制返回值
     }
};
~~~



+ ### logger的处理

  ```java
  // 全局变量
  @Capturing
  private Logger logger;
  ---
  new Expectations(SkyengineExecutors.class) {
       {
         logger.isDebugEnabled();
          result = true;
       }
  };
  
  ```

+ ### MockUp定制方法

  1. **在测试过程中，想让JavaMailSenderImpl的send发送异常，如下**：

  ~~~java
   new MockUp<JavaMailSenderImpl>() { // JavaMailSenderImpl mock对象
       @Mock  // 定制方法
       public void send(MimeMessage mimeMessage) throws MailException {
              // 定制类容
              throw new MailAuthenticationException("test Exception");
      }
  };
  ~~~

  2. **在测试抽象方法中与这样一段代码**：

  ~~~java
     protected int getTimes(AlarmConfigEntity alarmConfigEntity) {
          return 1;
     }
  ~~~

  getTimes方法都是返回1，那么在下面的代码中times > 1 将恒不等，

  ~~~java
  boolean isNeedRecordDetail = times > 1 && alarmConfigEntity.getEnableRecordDetail();
  ~~~

   那么我们将定制getTimes方法，如下：

  ~~~java
   new MockUp<MethodMane>() {
         @Mock
         public int getTimes(AlarmConfigEntity alarmConfigEntity) {
               return 2;
         }
   };
  ~~~

  并且该方法在测试类中，因此**MockUp可以对测试类自身的方法进行定制**

