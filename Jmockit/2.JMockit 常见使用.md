## 2.JMockit 常见使

1. **mock静态方法**

   在mock静态方法时，只要在Record时，传入对应的MethodClass.class即可，如下：

   ~~~java
       new Expectations(LocaleI18nResolver.class){
            {
                LocaleI18nResolver.resolve(anyString, anyString, anyString);
                result = ... // 定制返回值
            }
       };
   ~~~

   ------

2. **logger的处理**

   ```java
   // 全局变量
   @Capturing
   private Logger logger;
   ---
       new Expectations() {
            {
              logger.isDebugEnabled();
               result = true;
            }
       };
   ```

   -----

3. **MockUp定制方法体**

   - 在测试过程中，想让JavaMailSenderImpl的send方法异常，如下

   ~~~java
       new MockUp<JavaMailSenderImpl>() { // JavaMailSenderImpl mock对象
            @Mock  // 定制方法
            public void send(MimeMessage mimeMessage) throws MailException {
                   // 定制内容
                   throw new MailAuthenticationException("test Exception");
           }
       };
   ~~~

   - 在测试抽象方法中与这样一段代码

     ~~~java
         protected int getTimes(AlarmConfigEntity alarmConfigEntity) {
                 return 1;
          }
     ~~~

     getTimes方法都是返回1，那么在下面的代码中times > 1 将恒不等

     ~~~java
        boolean isNeedRecordDetail = times > 1 && alarmConfigEntity.getEnableRecordDetail();
     ~~~

     那么我们将定制getTimes方法，如下：

     ~~~java
         new MockUp<MethodMane>() {
                @Mock
                public int getTimes(AlarmConfigEntity alarmConfigEntity) {
                      return 2;
                }
         };
     ~~~

   - MockUp可以对测试类自身的方法进行定制

     -----

4. **接口分页查询定制返回结果，接口返回值类型为：Page<ClassName> page**

   ~~~java
       List<ClassName> classNameList = new ArrayList<>();
   
       ClassName className = new ClassName();
   
       --对className赋值--
   
       classNameList .add(className );
   
       Page<ClassName> page = new PageImpl<>(classNameList , PageRequest.of(0, 1), classNameList .size());
   ~~~

   

5. **发的发达**

6. **的**


